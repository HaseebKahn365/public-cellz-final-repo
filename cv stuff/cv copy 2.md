
# Abdul Haseeb ‚Äî Flutter & Dart Developer (3+ Years)

**Email:** [haseebkahn365@gmail.com]  
**GitHub:** [github.com/HaseebKahn365](https://github.com/HaseebKahn365)  
**Phone:** 03491777261
**Location:** [Shergarh, Tehsil Takht Bhai, District Mardan, KPK, Pakistan]  


---

## üéØ Profile Summary

Innovative Flutter and Dart developer with a rich background in architecting mobile games, agentic systems, productivity tools, and simulation-based educational apps. Demonstrated expertise in advanced state management, clean architecture, AI-driven game logic, and offline-first mobile experiences.

---

## üß± Current Focus (2025)

- üîÅ **Building Agentic Apps with Gemini + Flutter**
- üßº **Mastering Clean Architecture in Flutter**

---

## üóìÔ∏è Timeline of Flutter/Dart Projects

- **2023**: UI/logic experiments for Cellz, console-based AI in Dart
- **Late 2023**: Firebase, multiplayer (Cellz_m3), SRT simulator
- **2024**: SQLite + Firestore apps, Clean Architecture (Sohail Hospital, Maize, State_Manag)
- **Late 2024**: AI_ES (AI Assistant Embedded Systems) with voice control
- **2024‚Äì2025**: Released **Cellz Final** on [Google Play Store](https://play.google.com/store/apps/details?id=com.sytaxr.cellzfinale)


---

## üèÅ Released Work

üéÆ **Cellz Final**  
‚ñ∂Ô∏è [Available on Google Play Store](https://play.google.com/store/apps/details?id=com.sytaxr.cellzfinale)


<center>

## üóìÔ∏è Gantt Chart of Projects
</center>

```mermaid
gantt
  title üöÄ Flutter & Dart Development Journey
  dateFormat  YYYY-MM-DD
  axisFormat %b %Y
  
  CellzV2 Console        :active, a2, 2023-09-02, 10d, click href "#repo1", "View CellzV2 Console details"
  Clonstify              :active, a4, 2023-07-30, 2d
  MagicCalculator        :active, a5, 2023-08-04, 4d
  SRT Simulator          :active, b1, 2023-12-02, 4d
  Data Structures CW     :active, b2, 2023-12-15, 2024-01-03
  S. Sohail Hospital     :active, c1, 2024-02-28, 2024-06-03
  Provider_v2            :active, c2, 2024-01-23, 2d
  Maize Beta             :active, c3, 2024-04-04, 2024-05-01
  State_Manag            :active, c4, 2024-06-01, 4d
  AI_ES                 :active, c5, 2024-12-06, 2025-02-17
  Cellz Final(released)            :crit, c5, 2024-07-01, 2025-05-01
```



## üì∫ YouTube Demos

- **Cellz Final:** [https://www.youtube.com/shorts/j5SUzB2qKn4](https://www.youtube.com/shorts/j5SUzB2qKn4)
- **Maize Beta:** [https://studio.youtube.com/video/FC3Ki9xOpis/edit](https://studio.youtube.com/video/FC3Ki9xOpis/edit)
- **AI_ES:** [https://www.youtube.com/shorts/llRoVSH5-y4](https://www.youtube.com/shorts/llRoVSH5-y4)
             [Practical Demo of AI Assistant](https://youtu.be/TA5H0k3W5yM?si=AWWgRXFfew2WuGQf)
             [https://youtu.be/TA5H0k3W5yM?si=AWWgRXFfew2WuGQf](https://youtu.be/TA5H0k3W5yM?si=AWWgRXFfew2WuGQf)




<center id="repo1">

  # Repo 1: CellzV2Console
</center>

## Overview

CellzV2Console is a terminal-based implementation of the classic Dots and Boxes game in Dart. This version was created to test and validate the core game logic, AI strategies, and algorithms before implementing them in the Flutter mobile version.

## Timeline

September 2023 (2-11 September commit dates)

## Core Features

- Console-based interface for testing game mechanics
- AI opponent with multiple difficulty levels
- Square completion detection algorithms
- Line placement validation
- Score tracking

## Technical Implementation

- Pure Dart implementation without UI framework
- Command line interface for input/output
- Object-oriented design with core game classes
- AI strategy testing environment

## Testing Focus

- Square detection algorithms
- Line placement validation
- AI opponent strategies
- Score calculation
- Game state management

## Developer Role

As sole developer, implemented:

- Core game logic
- Input validation
- Square detection
- AI opponent logic
- Terminal interface

The project served as a proof-of-concept for the core game mechanics before building the full Flutter version.




<center>

# Repo 2: Clonstify
</center >

## Project Information

**GitHub:** [HaseebKahn365/clonstify](https://github.com/HaseebKahn365/clonstify)  
**Timeline:** July 30-31, 2023

## Overview

A Flutter-based Spotify UI clone replicating core visual experience and layout. Focuses on responsive design and Flutter UI implementation techniques.

### Target Audience

Flutter developers studying UI implementation and responsive design patterns.

### Core Goals

- Demonstrate Flutter UI capabilities
- Showcase responsive design implementation
- Provide reference for complex layouts and state management

## Technical Architecture

### Core Components

- **Main Shell Layout**: Conditional rendering based on screen size
- **PlaylistScreen**: Main interface showing playlist details and tracks
- **Provider-based State**: Uses CurrentTrackModel for track selection

### Communication Pattern

Components communicate through Provider pattern:

- TracksList updates CurrentTrackModel
- Components observe changes through Provider

### Data Handling

Uses static data models from `data.dart` for playlists and tracks.

## Key Features

### üé® Responsive UI

- Breakpoint at 800px width
- Conditional component rendering
- Adaptive layouts for different screen sizes

### üìë Playlist Display

- Artwork visualization
- Title and description display
- Creator information
- Responsive layout adjustments

### üéµ Track Selection

- Data table implementation
- Selection functionality
- Current track model updates

### üéÆ Player Controls

- Play/pause simulation
- Skip functionality
- Volume control interface

## Technical Implementation

### Flutter/Dart Skills

- Provider state management
- MediaQuery responsive design
- Custom widget creation
- Complex layout techniques
- Theme customization

### Architecture

- Component-based design
- Provider state management
- Modular file structure

### Third-Party Dependencies

- `provider`: State management
- `desktop_window`: Window size constraints

## Advanced Features

- Cross-platform considerations
- Breakpoint-based responsive design
- Platform-specific behavior handling

## Technical Challenges & Solutions

### 1. Responsive Layout

**Challenge:** Adaptive UI across screen sizes  
**Solution:** Breakpoint-based conditional rendering

### 2. Theme Consistency

**Challenge:** Maintaining visual styling  
**Solution:** Comprehensive theme definition system

### 3. State Management

**Challenge:** Cross-component state sharing  
**Solution:** Provider pattern implementation

## Developer Role

Sole contributor: Abdul Haseeb (HaseebKahn365)  
Implementation period: July 30-31, 2023








<center>

# Repo 3: Dart-2024:
</center>

## What You Learned in the Dart_Language_Practice Repository

Based on the code snippets and wiki pages available, this repository serves as a comprehensive learning resource for Dart programming language fundamentals and advanced concepts. Here's a detailed breakdown of what you learned:

### 1. Core Dart Language Features

#### Type System

You explored Dart's static type system, including:

- Basic types (int, double, String, bool)
- Type inference with var
- Explicit typing
- Type conversion methods  
  `_3buildInTypes.dart:6-11`

#### Variable Declaration

You learned different ways to declare variables:

- Using var for type inference
- Using explicit types
- Using final for single-assignment variables
- Using const for compile-time constants  
  `late_keyword.dart:36-40`

#### The `late` Keyword

You explored how to use the late keyword for:

- Deferred initialization of non-nullable variables
- Lazy initialization
- Combining with final for single-assignment variables with deferred initialization  
  `late_keyword.dart:34-38`

#### Control Flow

You learned various control flow structures:

- Conditional statements (if/else, switch/case)
- Loops (for, while, do-while)
- Exception handling with try/catch/finally  
  `_93DartControlFlow.dart:44-55`

### 2. Collections and Data Structures

#### Lists

You learned how to create and manipulate lists:

- Creating lists using literals, constructors, and generators
- Adding, accessing, and modifying list elements
- Using list methods like add(), sort(), etc.  
  `_4lists.dart:10-19`

#### Dot Operators for Collections

You explored special operators for collections:

- Cascade operator (..) for performing multiple operations on the same object
- Spread operator (...) for inserting elements from one collection into another
- Collection if and for for conditional and loop-based collection creation  
  `_5dotOperators.dart:12-17`

#### Maps

You learned how to work with key-value pairs using Maps:

- Creating maps using literals and constructors
- Accessing and modifying map elements
- Iterating through maps
- Practical applications like calculating averages from nested data structures  
  `_5problemMap.dart:34-53`

### 3. Functions and Higher-Order Functions

#### Function Types

You explored different function types:

- Required positional parameters
- Optional positional parameters
- Required named parameters
- Optional named parameters
- Hybrid parameter patterns  
  `_9dartFunction.dart:50-73`

#### Higher-Order Functions

You learned about functions that take other functions as parameters or return functions:

- Passing functions as arguments
- Returning functions from functions (closures)
- Using anonymous functions (lambdas)
- Function type definitions  
  `_9OperatorsOnCollection.dart:2-11`

#### Custom Higher-Order Functions

You implemented your own higher-order functions:

- A transform<T, R> function that applies a transformation to each element of a list
- A custom where<T> function that filters elements based on a condition  
  `_9OperatorsOnCollection.dart:23-32`

### 4. Object-Oriented Programming

#### Classes and Objects

You learned how to define and use classes:

- Creating class constructors
- Defining instance variables and methods
- Using the this keyword  
  `FactoryConstructorExercise.dart:1-21`

#### Factory Constructors

You explored factory constructors for creating objects in special ways:

- Converting from JSON to objects
- Converting objects to JSON  
  `FactoryConstructorExercise.dart:6-15`

#### Operator Overloading

You learned how to customize operator behavior for your classes:

- Overriding the equality operator (==)
- Implementing arithmetic operators like + and *
- Using the covariant keyword for type-specific operator parameters  
  `_2Equality.dart:13-26`

#### Generics

You explored generic programming for type-safe code:

- Creating generic classes with type parameters
- Constraining type parameters with bounds
- Using generics with collections and functions  
  `_98Generics.dart:1-24`

### 5. Asynchronous Programming

#### Futures

You learned about handling asynchronous operations with Futures:

- Creating and using Future objects
- Using async and await keywords
- Handling Future completion and errors

#### Streams

You explored working with sequences of asynchronous events:

- Creating and consuming streams
- Using async* and yield for stream generation
- Processing stream data with methods like reduce()  
  `_3Stream.dart:1-14`

### 6. Practical Applications

Throughout the repository, you applied these concepts to solve practical problems:

- Calculating averages from collections of data
- Transforming and filtering data
- Creating reusable utility functions
- Building simple data models with JSON serialization/deserialization  
  `_5problemMap.dart:45-53`

### Repository Structure

The repository is organized into several main directories:

- **Dart8hrCourse/**: Contains basic to intermediate Dart concepts
- **Mastering_Dart/**: Contains more advanced topics organized by concept:
  - **Collections/**: Advanced collection operations
  - **Classes/**: Object-oriented programming concepts
  - **AsynchronousProgramming/**: Futures, streams, and API usage

This structure allows for progressive learning, starting from core language features and building up to more complex concepts.

> **Notes:**  
> This repository is primarily focused on learning Dart language features rather than building Flutter applications. It serves as an excellent foundation for understanding the programming language that underlies Flutter development. The examples are concise and focused on demonstrating specific language features rather than building complete applications.




<center>

# Repo 4: Data-Structures-CW (Data Structures Coursework)

</center>

## GitHub Link

https://github.com/HaseebKahn365/Data-Structures-CW

## Timeline & Commitment

Based on the git commit timestamps in the provided snippets, the project appears to have been active from approximately December 2023 to January 2024. The earliest commit shown is from December 15, 2023, and the latest is from January 3, 2024.

## Project Overview

This repository contains a comprehensive collection of fundamental data structures and algorithms implementations in C++. It serves as both a practical toolkit and educational resource, covering essential computer science concepts from basic data structures to more complex application systems. The project focuses on core data structures like trees, hash tables, and linked lists, while also demonstrating their application in real-world scenarios such as encryption, smart home systems, and process scheduling.

The target audience appears to be computer science students or educators looking for practical implementations of data structures and algorithms concepts. The repository seems to be organized as coursework or educational material.

## Core Functionality

The repository is organized into several main systems:

### Core Data Structures:

- Binary Search Trees (BST) with various implementations
- AVL Trees (Self-Balancing BST)
- Hash Tables with different collision resolution strategies
- Linked Lists

### Application Systems:

- **Encryption/Compression System:** A hybrid system that selects between Alpha Substitution Cipher and Huffman Coding based on message length
- **Smart Home Simulation:** Demonstrates application of data structures in managing home devices and user preferences
- **Process Scheduling:** Implementations of various OS scheduling algorithms

The repository demonstrates how these data structures communicate and work together in practical applications. For example, the Smart Home system uses linked lists to manage persons and binary search trees to store user preferences.

## Key Features

### Binary Search Trees Implementation

- Includes specialized versions like AirplaneTree for scheduling
- Implements various tree operations including insertion, deletion, and traversal
- Demonstrates different node deletion strategies (leaf node, one child, two children)

### Hash Tables with Multiple Collision Resolution Strategies

- Implements linear probing, quadratic probing, and double hashing
- Provides dynamic resizing based on load factor monitoring
- Used in encryption components

### Hybrid Encryption/Compression System

- Automatically selects between Alpha Substitution Cipher (for shorter messages) and Huffman Coding (for longer messages)
- The Alpha Substitution Cipher implements a simple character substitution encryption
- Huffman Coding provides data compression by encoding characters based on frequency

### Smart Home Simulation

- Uses linked lists to manage persons (HPerson objects)
- Employs binary search trees to store and retrieve user preferences
- Includes various device classes to represent smart home components

### Process Scheduling Algorithms

- Implements various scheduling algorithms like Round Robin
- Demonstrates queue-based implementation for process management

## C++ Skills Demonstrated

Instead of Flutter/Dart skills (as this is a C++ project), here are the C++ skills demonstrated:

- Object-Oriented Programming: Extensive use of classes and inheritance
- Data Structures: Implementation of trees, linked lists, hash tables
- Algorithms: Tree traversal, encryption, compression, scheduling
- Memory Management: Dynamic allocation and deallocation
- Standard Template Library (STL): Usage of containers like vectors, queues, and maps

## Architecture & Design Decisions

The repository follows an object-oriented design with clear separation of concerns:

- Each data structure is implemented as its own class with well-defined interfaces
- Application systems are built on top of these core data structures
- The code is modular with different components handling specific responsibilities
- The folder structure appears to be organized by assignments or topics, with each folder containing related implementations.

## Third-Party Tools & Libraries

The code primarily uses standard C++ libraries:

- `<iostream>` for input/output operations
- `<string>` for string manipulation
- `<queue>` and `<vector>` for STL containers
- `<chrono>` for timing operations

## Advanced Concepts

- Self-Balancing Trees: Implementation of AVL trees with rotation operations
- Huffman Coding: Advanced compression algorithm using frequency analysis and variable-length codes
- Simulation Systems: Smart home simulation demonstrating real-world application of data structures

## Biggest Technical Challenges & Solutions

Based on the code complexity, some likely challenges were:

### Implementing Tree Balancing in AVL Trees

**Solution:** Careful implementation of rotation operations and balance factor calculations  
The code shows detailed implementation of left and right rotations to maintain tree balance

### Efficient Compression with Huffman Coding

**Solution:** Building frequency tables and constructing optimal Huffman trees  
The implementation shows careful bit manipulation for efficient storage

### Integrating Multiple Data Structures in Application Systems

**Solution:** Clear interfaces between components and thoughtful system design  
The Smart Home system demonstrates how different data structures can work together

## Role in the Project

Based on the git blame information, Abdul Haseeb appears to be the primary (or sole) contributor to this repository, implementing all the data structures and application systems shown in the snippets.

## Notes

This template has been filled out based on the available code snippets and wiki pages from the HaseebKahn365/Data-Structures-CW repository. The repository appears to be a collection of data structures and algorithms implementations in C++, likely created as coursework or educational material. The information about timeline is based on git commit timestamps in the provided snippets, which show activity from December 2023 to January 2024.

Since this is a C++ project focused on data structures and algorithms rather than a Flutter/Dart application, I've adapted section 7 to highlight C++ skills instead of Flutter/Dart skills as requested in the original template.





<center>

# Repo 5: MagicCalculator
</center>

## GitHub Link

https://github.com/HaseebKahn365/MagicCalculator

## Timeline & Commitment

August 2023 (Based on git commits from August 4-7, 2023)

## Project Overview

MagicCalculator is a fun Flutter application inspired by a YouTube magician's trick. It appears to be a regular calculator but has a magical twist - no matter what calculations users perform, the result always equals a secretly pre-selected phone number from their contacts!

The target audience is anyone who enjoys magic tricks and wants to surprise their friends with a seemingly impossible mathematical trick.

## Core Functionality

The app consists of two key components:

- A calculator interface that looks completely normal
- A hidden contact selector that sets up the "magic" trick

The trick works by letting the presenter secretly select a contact's phone number, after which any calculations performed will magically result in that number, creating an illusion of mathematical wizardry.

## Key Features

- Deceptively normal calculator interface
- Secret contact number selection through long-press of "!" button
- Magical result manipulation (always shows the pre-selected phone number)
- Convincing calculator animations and operations

## Flutter/Dart Skills Demonstrated

- UI design making the calculator look authentic
- State management to maintain the illusion
- Contact integration for the magic trick setup

## Technical Implementation

The magic happens through:

- Background number manipulation
- Stored contact number as the forced result
- Authentic-looking calculator operations that are actually staged

## Inspiration

Inspired by classic magician's props where seemingly random calculations always lead to a predetermined number. Modernized for the digital age by incorporating phone contacts as the "forced" number.

## Usage

1. Presenter secretly long-presses "!" to select a contact
2. Hands device to audience
3. Let them perform any calculations
4. Watch their amazement when results always match the chosen phone number

> **Note:** This app was created purely for entertainment purposes as a digital magic trick.







<center>

# Repo 6: Maiz-Game (Gyroscope controlled)

</center>

### GitHub Link:

[https://github.com/HaseebKahn365/maize_beta](https://github.com/HaseebKahn365/maize_beta)

### Timeline & Commitment:

**April 2024 ‚Äì May 2024**  
(Based on commit dates from April 4, 2024 to May 1, 2024)

---

### Project Overview:

**Maize Beta** is a Flutter-based mobile game that combines maze navigation with collection mechanics and gyroscope controls. Players navigate through maze-like levels using their device's gyroscope to control movement, collecting items while avoiding obstacles. The game features a social leaderboard system that ranks players based on their performance metrics across different levels.

The target audience is casual mobile gamers who enjoy physics-based maze games with competitive elements.

The core goals of the app are to provide an engaging maze navigation experience with gyroscope controls, implement a progression system through multiple levels, and create a competitive social environment through leaderboards.

---

### Core Functionality:

#### Screens/Pages and Flow:

The app consists of three main screens accessible through a navigation bar:

- **HomeScreen**: Main game interface that launches gameplay.
- **JourneyScreen**: Visualizes player progress through levels using a timeline interface.
- **LeaderBoardScreen**: Shows player rankings with filtering options by country and level.

#### Business Logic Layers:

The game uses a layered architecture:

- **User Interface Layer**: Manages screens and user interactions.
- **Game Engine Layer**: Powers gameplay mechanics using the Flame engine.
- **Data Persistence Layer**: Handles data storage and retrieval.

#### Communication Between Modules:

The game engine communicates with UI components through **ValueNotifiers** for reactive updates to score, time, and player health. Data flows between the game engine and persistence layers when levels are completed, with results being saved locally and potentially synced to Firestore if they qualify for leaderboard positions.

#### Real-Time or Offline Behavior:

The game functions primarily offline with local SQLite storage for player progress. Online features include leaderboards that sync with Firestore when the device has connectivity. The bi-daily leaderboard updates optimize network usage while maintaining competitive elements.

#### User Data Handling:

The app implements a dual-database architecture:

- **Local SQLite Database**: Stores player profiles, completed levels, and gameplay history.
- **Cloud Firestore Database**: Manages social features with three collections (Users, Levels, LeaderBoard).

#### Error, State, Navigation, and Animations Management:

- **State Management**: Uses ValueNotifiers for reactive UI updates based on game state.
- **Navigation**: Implemented through a bottom navigation bar for switching between main screens.
- **Animations**: Utilizes `flutter_animate` package for UI animations.
- **Error Handling**: Implements try-catch blocks for database operations with user feedback through SnackBars.

---

### Key Features:

- **Gyroscope-Based Player Control**  
  Players control their character using the device's gyroscope, providing an intuitive and immersive control scheme. This was implemented using the `sensors_plus` package to access device motion sensors.

- **Level-Based Progression System**  
  The game features multiple levels with increasing difficulty, loaded from Tiled map files. This approach allows for flexible level design and easy content updates.

- **Collectible Items System**  
  Players can collect various items (hearts, diamonds, shrinkers, trophies) that affect gameplay. These collectibles influence player score and position on leaderboards.

- **Dual-Database Architecture**  
  The app uses both local SQLite storage and cloud Firestore databases to provide offline functionality while enabling social features when online.

- **Sophisticated Leaderboard System**  
  The leaderboard implements a tiered approach with precise tracking for top players and threshold-based ranking for others, optimizing data transfer while providing meaningful competitive information.

- **Visual Journey Timeline**  
  Players can visualize their progress through a timeline interface showing completed levels and their ranking position relative to other players.

---

### Flutter/Dart Skills Demonstrated:

- **State Management**  
  Uses ValueNotifiers for reactive state management, particularly for game metrics like score, time elapsed, and player health that need to update the UI in real-time.

- **Async Programming & Future/Stream Use**  
  Extensively uses async/await patterns for database operations, with Futures for handling database queries and updates.

- **Custom Widgets**  
  Implements custom reusable components like `PlayerListTile` for the leaderboard display and timeline tiles for the journey screen.

- **Database Integration**  
  Demonstrates sophisticated database design and integration with both SQLite and Firestore, including complex query patterns and data synchronization.

- **Game Development with Flame**  
  Utilizes the Flame game engine for 2D game development, including sprite rendering, collision detection, and game loop management.

---

### Architecture & Design Decisions:

#### Architecture Pattern:

The app follows a layered architecture with clear separation between UI, game engine, and data persistence layers. This approach enhances maintainability and testability.

#### Folder Structure:

The project uses a feature-based organization with specialized directories:

- `lib/Screens/`: UI screens and components.
- `lib/Database_Services/`: Database integration.
- `lib/Firebase_Services/`: Cloud services.
- `lib/GeneralRepresentation/`: Data models.
- `lib/TimelineComponents/`: Journey screen components.

#### Modularity and Testability:

The codebase demonstrates good separation of concerns with dedicated service classes for database operations and clear interfaces between components, making it more testable and maintainable.

---

### Third-Party Tools & Packages:

- **Flame (Game Engine)**  
  Used for 2D game development, providing a structured framework for game loop management, sprite rendering, and collision detection.

- **Flame Tiled**  
  Integrates Tiled map editor with the Flame engine, allowing for complex level design using external tools.

- **sensors_plus**  
  Provides access to device sensors, particularly the gyroscope for player movement control.

- **sqflite**  
  Used for local database storage of player profiles, levels, and gameplay history.

- **cloud_firestore**  
  Implements cloud database functionality for social features like leaderboards.

- **flutter_animate**  
  Provides animation capabilities for UI elements, enhancing visual feedback.

- **timeline_tile**  
  Used to create the visual progression timeline in the Journey screen.

- **country_picker**  
  Integrates country selection functionality for player profiles.

---

### Advanced Concepts:

- **Optimized Cloud Data Synchronization**  
  The app implements a sophisticated threshold-based ranking system that minimizes data transfer while still providing meaningful competitive information to players.

- **Offline-First Architecture**  
  The game functions fully offline with local data storage, syncing to cloud services only when needed for social features.

- **Sensor-Based Gameplay**  
  Utilizes device gyroscope for player control, creating a unique and immersive gameplay experience.

---

### Biggest Technical Challenges & Solutions:

1. **Efficient Leaderboard Implementation**  
   - **Challenge**: Creating a leaderboard system that provides meaningful ranking information without excessive data transfer or storage requirements.  
   - **Solution**: Implemented a tiered approach with precise tracking for top 10 players and threshold-based ranking for others (positions 100, 200, etc.), optimizing data transfer while still giving players a sense of their relative position.

2. **Gyroscope Control Precision**  
   - **Challenge**: Implementing responsive and intuitive player control using the device gyroscope.  
   - **Solution**: Used the `sensors_plus` package with calibration and sensitivity adjustments to create a smooth control experience across different devices.

3. **Dual-Database Synchronization**  
   - **Challenge**: Managing data consistency between local SQLite storage and cloud Firestore.  
   - **Solution**: Implemented a clear data flow where game results are first saved locally, then selectively synchronized to Firestore based on ranking eligibility, with careful transaction management to prevent data corruption.

---

### My Role:

Based on the git blame information, it appears that **Abdul Haseeb** was the primary (or sole) developer on this project, implementing all aspects from the initial setup to the final features. The commits span from April 4, 2024 to May 1, 2024, showing consistent development throughout this period.

---

### Notes:

This comprehensive template provides an overview of the **Maize Beta** project based on the available code snippets and wiki information. The project appears to be a Flutter-based mobile game that combines maze navigation with gyroscope controls and social leaderboard features. The implementation shows sophisticated database design with both local and cloud storage, and a focus on optimizing the competitive aspects of the game.

The timeline information is inferred from commit dates in the provided snippets, showing development from early April to early May 2024.








<center>

# Repo 7: Provider_v2

</center>

### GitHub Link:

[https://github.com/HaseebKahn365/provider_v2](https://github.com/HaseebKahn365/provider_v2)

### Timeline & Commitment:

**January 23, 2024 ‚Äì January 24, 2024** (based on commit timestamps)

---

### Project Overview:

The **provider_v2** project is a Flutter application that demonstrates the Provider pattern for state management. It serves as a practical example of implementing the Provider package to efficiently manage application state in Flutter.

The target audience is Flutter developers who want to learn about state management using the Provider package.

The core goals of the app are to showcase key Provider concepts including multiple providers, ChangeNotifier implementation, and reactive UI updates.

---

### Core Functionality:

#### Screens/Pages and Flow:

The app consists of a main screen (**HomeView**) that displays a list of activities and user controls. When the number of activities exceeds 20, the app navigates to a new screen (**NewScreen**).

#### Business Logic Layers:

The business logic is encapsulated in model classes (**Human** and **Category**) that extend `ChangeNotifier`. These models contain the data and methods to manipulate that data.

#### Communication Between Modules:

The app uses Provider to facilitate communication between UI components and data models. When a model's state changes, it calls `notifyListeners()` to update all widgets that depend on that state.

#### Real-Time Behavior:

The app demonstrates real-time UI updates when state changes, such as increasing a person's age or adding/removing activities.

#### User Data Handling:

User data (**Human model** and **Category model** with activities) is managed in memory using Provider. There is no persistent storage implementation.

#### State, Navigation, and Animations Management:

- **State**: Managed using Provider and `ChangeNotifier`.
- **Navigation**: Handled using Flutter's `Navigator`.
- **Animations**: Implemented using the `animation_list` package.

---

### Key Features:

- **Multiple Providers**:  
  Implemented using `MultiProvider` to provide both **Human** and **Category** models to the widget tree. This allows different parts of the app to access different state providers.

- **Reactive UI Updates**:  
  Uses `ChangeNotifier` and `notifyListeners()` to automatically update the UI when state changes, creating a reactive user experience.

- **Different Provider Access Methods**:  
  Demonstrates different ways to access provider state using `Provider.of` and `context.read`.

- **Animated Lists**:  
  Uses the `AnimationList` component to create visually appealing list animations.

The app simulates real-time process scheduling using:
- A timer that triggers CPU cycles every second
- Visual feedback showing process execution and preemption
- System clock that tracks simulation time

### User Data Handling
The app doesn't persist user data. All process data is stored in memory during the simulation:
- `activeProcesses` list contains processes in the scheduler
- `tempCreated` list holds newly created processes
- Process state is updated in real-time during simulation

### Error, State, Navigation, and Animations Management
- **State**: Managed using Flutter's `setState()` mechanism
- **Errors**: Caught and logged during CPU cycles
- **Navigation**: Minimal (single screen with an about page)
- **Animations**: Implemented through UI updates driven by the timer

---

## Key Features

### Interactive Process Creation
Users create processes by holding the "Create Process" floating action button, with the burst time determined by the duration of the press. This provides an intuitive way to create processes with different execution times.

### Real-Time SRT Scheduling Visualization
The app visually demonstrates how the SRT algorithm works by showing process preemption and execution in real-time, with processes sorted by remaining burst time.

### Process Queue Management
Users can create multiple processes and add them to the scheduler in batches, allowing for experimentation with different process arrival patterns.

### Visual Process Differentiation
Each process is assigned a random color for easy visual identification throughout its lifecycle in the system.

---

## Flutter/Dart Skills Demonstrated

### State Management
The app uses Flutter's built-in `setState()` mechanism for state management, updating the UI in response to:
- Timer-driven CPU cycles
- User interactions (process creation, adding processes to the scheduler)
- Algorithm execution (process sorting, completion)

### Async Programming & Future/Stream Use
The app demonstrates async programming through:
- Timer-based simulation of CPU cycles
- Periodic execution of the scheduling algorithm
- Handling long-press gestures for process creation

### Custom Widgets
The app implements several custom widgets:
- `ActiveProcesses` widget for displaying the ready queue
- `Processor` widget for visualizing the CPU
- Process cards with dynamic coloring and information display

### Gesture Recognition
The app uses gesture detection for process creation, with a long-press gesture controlling the burst time of new processes.

---

## Architecture & Design Decisions

### Architecture Pattern
The app uses a simple monolithic architecture with a single stateful widget managing the entire application state. This approach is appropriate for the app's educational purpose and limited scope.

### Folder Structure
The project has a minimal folder structure with:
- Main application code in `lib/main.dart`
- About page in `lib/about_me.dart`
- `Process` class in `lib/classes_and_vars/process.dart`

### Modularity
The app demonstrates some modularity through:
- Separation of the `Process` class
- Custom widgets for different UI components
- Clear separation of algorithm logic from UI code

---

## Third-Party Tools & Packages
- **url_launcher**: Used to open the GitHub repository link from the about page, providing easy access to the source code.
- **simple_icons**: Used in the about page to display the GitHub icon, enhancing the visual appeal of the source code link.

---

## Advanced Concepts

### Algorithm Visualization
The app provides a real-time visualization of a complex operating system scheduling algorithm, making abstract concepts concrete and interactive.

### Educational Tool Design
The app is designed as an educational tool, with clear visual feedback and interactive elements that help users understand the SRT algorithm.

---

## Biggest Technical Challenges & Solutions

### Real-Time Process Scheduling Simulation
- **Challenge**: Implementing a real-time simulation of the SRT algorithm that accurately reflects how processes are scheduled in an operating system.
- **Solution**: Used a timer-based approach to simulate CPU cycles, with the `runCycle()` method reducing the burst time of the executing process and the `adjustPositions()` method implementing the SRT algorithm logic.

### Intuitive Process Creation Interface
- **Challenge**: Creating an intuitive way for users to create processes with different burst times.
- **Solution**: Implemented a long-press gesture on the "Create Process" button, where the duration of the press determines the burst time of the new process, providing a direct and intuitive connection between user action and process attribute.

### Visual Process Differentiation
- **Challenge**: Making it easy for users to track individual processes through the scheduling lifecycle.
- **Solution**: Assigned a random color to each process and used consistent color coding across all UI components, making it easy to visually identify and track processes.

---

## My Role
As the sole developer (**Abdul Haseeb**), I implemented the entire application, including:
- Core algorithm implementation
- UI design and implementation
- Process creation and management
- Simulation engine

---

## Notes
This comprehensive repo information is based on the SRT Simulator project, which is a Flutter application demonstrating the Shortest Remaining Time scheduling algorithm. The project was developed by Abdul Haseeb in December 2023, as evidenced by the commit dates in the code snippets. The application serves as an educational tool for understanding process scheduling in operating systems, with a focus on visual representation and interactive learning.







<center>

# Repo 8: S_Sohail_Hospital
</center>
**S. Sohail Hospital (s_sohail)**

## 2. GitHub Link:
[https://github.com/HaseebKahn365/s_sohail](https://github.com/HaseebKahn365/s_sohail)

## 3. Timeline & Commitment:
**February 2024 ‚Äì June 2024**  
(Based on commit dates from February 28, 2024, to June 3, 2024)  
`buisiness_logic_and_classes.dart:10`

## 4. Project Overview:
The S. Sohail Hospital System is a Flutter-based application designed to manage hospital operations including patient records, doctor information, visit history, and payment processing. It enables hospital staff to register patients, record medical visits, assign doctors, process payments, and view historical patient data. 

The target audience is hospital administrative staff who need to manage patient information and billing in a small to medium-sized hospital setting. The core goal is to provide a simple yet effective solution for patient record management with persistent local storage.  
`README.md:3-7`

## 5. Core Functionality:

### Screens/Pages and Flow:
The application consists of three main screens:
- **HomeScreen**: Displays a list of patients with search functionality and allows adding new patients.
- **PatientScreen**: Shows detailed patient information, allows recording visits and processing payments.
- **DatabaseTableView**: A utility screen for viewing raw database tables.  
`main.dart:106-109`  
`patient_screen.dart:72-75`

### Business Logic Layers:
The application uses a central `HospitalSystem` class that extends `ChangeNotifier` to manage application state and business logic. This class maintains collections of patients, visits, and doctors, and provides methods for CRUD operations.  
`buisiness_logic_and_classes.dart:15-18`

### Communication Between Modules:
The application follows a hierarchical communication pattern:
- UI components (screens) interact with the `HospitalSystem` class.
- `HospitalSystem` communicates with the `PatientService` for database operations.
- `PatientService` handles SQLite database interactions.  
`buisiness_logic_and_classes.dart:30`

### Real-Time or Offline Behavior:
The application is designed for offline use with local data persistence using SQLite. Changes are stored locally and don't require internet connectivity.

### User Data Handling:
User data is handled through CRUD operations implemented in the `HospitalSystem` class and persisted in a local SQLite database. The application uses the `PatientService` class to interact with the database.  
`buisiness_logic_and_classes.dart:78-85`  
`buisiness_logic_and_classes.dart:87-92`

### Error, State, Navigation, and Animations Management:
- **State Management**: Uses Flutter's built-in `ChangeNotifier` pattern through the `HospitalSystem` class.
- **Navigation**: Uses Flutter's standard navigation with `Navigator.push`.
- **Animations**: Implements animations using the `flutter_animate` package.
- **Error Handling**: Basic error handling with `try-catch` blocks.  
`main.dart:423-432`  
`main.dart:436-444`

## 6. Key Features:

### Patient Management:
Allows adding, viewing, and deleting patients. Implemented using SQLite for persistence and a central state management system to keep UI in sync with data changes.  
`buisiness_logic_and_classes.dart:78-85`

### Visit Recording:
Enables recording patient visits with diagnosis details, amount charged, and doctor assignment. Uses a form-based approach with validation to ensure data integrity.  
`buisiness_logic_and_classes.dart:87-92`

### Payment Processing:
Provides functionality to process payments either through insurance or direct methods. Implemented as a dialog-based workflow with options for different payment methods.  
`patient_screen.dart:328-339`

### Doctor Assignment:
Allows assigning doctors to patient visits. Implemented using a simple selection mechanism with visual feedback.  
`main.dart:271-276`

### Search Functionality:
Provides real-time search filtering of patients. Implemented using text input and list filtering.  
`main.dart:391-393`

### Database Visualization:
Offers a raw view of database tables for debugging and administrative purposes. Implemented as a separate screen with formatted table views.  
`database_view.dart:28-35`

## 7. Flutter/Dart Skills Demonstrated:

### State Management:
Uses a hybrid approach combining Flutter's built-in `ChangeNotifier` pattern for application-wide state and `StatefulWidget` for local UI state. Riverpod is set up for dependency injection but not fully utilized for state management.  
`buisiness_logic_and_classes.dart:15`  
`main.dart:16-20`

### Routing:
Uses Flutter's standard navigation system with `Navigator.push` for screen transitions.  
`main.dart:423-432`

### Forms and Validation:
Implements form inputs with controllers for data entry and basic validation.  
`patient_screen.dart:36-37`

### Async Programming & Future/Stream Use:
Extensively uses `async/await` for database operations and UI updates.  
`buisiness_logic_and_classes.dart:33`  
`patient_screen.dart:50-55`

### Widgets:
Implements custom UI components and uses Flutter's material design widgets. Uses expansion tiles, cards, and list tiles for structured data display.  
`main.dart:403-419`

## 8. Architecture & Design Decisions:

### Architecture Pattern:
The application follows a simplified MVC-like pattern:
- **Model**: Database entities and services (`DatabasePatient`, `DatabaseVisit`, `PatientService`).
- **View**: UI components (`HomeScreen`, `PatientScreen`).
- **Controller**: `HospitalSystem` class that manages state and business logic.  
`buisiness_logic_and_classes.dart:15-24`

### Folder Structure:
The codebase is organized into:
- `lib/`: Main application code.
- `classes_and_vars/`: Business logic and data models.
- `screens/`: UI components.
- `services/`: Database and other services.  
`buisiness_logic_and_classes.dart:1`  
`patient_screen.dart:1`

### Testability and Modularity:
The application has some separation of concerns with business logic isolated in the `HospitalSystem` class, but lacks comprehensive testing infrastructure. The modular design allows for components to be developed and tested independently.

## 9. Third-Party Tools & Packages:
- **sqflite**: Used for SQLite database operations to provide local data persistence.
- **flutter_riverpod**: Set up for dependency injection but not fully utilized.
- **flutter_animate**: Used for UI animations to enhance user experience.
- **fluentui_system_icons**: Used for enhanced UI icons.
- **url_launcher**: Used for linking to external resources (GitHub).  

`main.dart:317`

## 10. Advanced Concepts:

### Offline Support:
The application is designed to work entirely offline with local data persistence using SQLite.  
`buisiness_logic_and_classes.dart:33-44`

### Database Triggers:
Implements SQLite triggers for maintaining deleted patient records, demonstrating advanced database concepts.  
`buisiness_logic_and_classes.dart:63-73`

## 11. Biggest Technical Challenges & Solutions:

### Challenge 1: Efficient State Management
- **Problem**: Keeping UI in sync with database changes.
- **Solution**: Implemented a central `HospitalSystem` class that extends `ChangeNotifier` to provide reactive updates to the UI when data changes.  
`buisiness_logic_and_classes.dart:15`  
`buisiness_logic_and_classes.dart:44`

### Challenge 2: Data Persistence
- **Problem**: Ensuring data is properly stored and retrieved from SQLite.
- **Solution**: Created a structured database service with proper models and CRUD operations.  
`buisiness_logic_and_classes.dart:30-45`

### Challenge 3: Deleted Patient Records
- **Problem**: Maintaining a history of deleted patients.
- **Solution**: Implemented SQLite triggers to automatically copy deleted patient records to a separate table.  
`buisiness_logic_and_classes.dart:63-73`

## 12. My Role:
Based on the git blame information, it appears that Abdul Haseeb was the primary (or sole) developer of this project, implementing all aspects from UI design to database integration. The project shows consistent commit patterns from February to June 2024, with Abdul Haseeb making all the commits.  
`buisiness_logic_and_classes.dart:1`

---

## Notes:
This template provides a comprehensive overview of the S. Sohail Hospital project based on the available codebase context. The project is a Flutter application for hospital management with SQLite for local data persistence. The implementation uses a hybrid state management approach with `ChangeNotifier` and `StatefulWidget`, with some initial setup for Riverpod that wasn't fully utilized. The project demonstrates skills in Flutter UI development, state management, database operations, and asynchronous programming.














<center>

# Repo 9: State Management Demonstration
</center>
**state_manag (State Management Demonstration)**

## 2. GitHub Link:
[https://github.com/HaseebKahn365/state_manag](https://github.com/HaseebKahn365/state_manag)

## 3. Timeline & Commitment:
**June 2024** (Based on commit dates from June 1-4, 2024 seen in the code snippets)  
`main.dart:1-5`

## 4. Project Overview:
This project is a Flutter application demonstrating different state management approaches in a university management system. It showcases multiple implementations of the same core functionality using Provider, GetX, and MobX state management patterns.

The target audience is Flutter developers looking to understand and compare different state management techniques in a real-world application context.

The core goals include demonstrating hierarchical data management, reactive UI updates, and proper separation of business logic from UI components across different state management approaches.  
`main.dart:1-5`

## 5. Core Functionality:

### Screens/pages and flow:
The application has multiple implementations, each with a similar screen flow:

- Login screen with tabs for student and teacher authentication
- Registration screen for new users
- Student dashboard showing courses and exams
- Teacher dashboard for managing courses and exams
- Exam screens for taking/creating exams

In the state management demonstrations, there's a consistent pattern of:

- Category screens listing categories
- Activity screens showing activities within categories
- Record screens displaying records for activities  
`main.dart:76-84`  
`mobix_screens.dart:90-95`

### Business logic layers:
The application separates business logic from UI through model classes:

- Core models (University, Student, Teacher, Course, Exam)
- State management-specific models (Parent, Category, Activity, Record)

Each implementation (Provider, GetX, MobX) has its own business logic implementation with similar functionality but using different state management patterns.  
`cep_business_logic.dart:36-40`

### Communication between modules:
- **In Provider**: Uses `ChangeNotifier` and `notifyListeners()` for state updates  
- **In GetX**: Uses reactive (`.obs`) variables and controllers  
- **In MobX**: Uses `@observable` properties and `@action` methods with automatic code generation  
`mobix_buisiness_logic.dart:12-17`

### Real-time or offline behavior:
The application operates with in-memory data without persistence. It generates mock data at startup and maintains state during the application session.  
`main.dart:34-35`

### User data handling:
User data (students, teachers, courses, exams) is stored in memory without local storage or backend integration. The application includes mock data generation for demonstration purposes.  
`cep_business_logic.dart:36-52`

### State, navigation, and error management:
- **State**: Managed through Provider, GetX, or MobX depending on the implementation  
- **Navigation**: Uses Flutter's `Navigator` for screen transitions  
- **Error handling**: Includes basic validation and error dialogs  
`main.dart:85-87`

## 6. Key Features:

### University Management System:
A core system with students, teachers, courses, and exams. Implements authentication, registration, and dashboard views for both student and teacher roles.  
`cep_business_logic.dart:36-85`

### Provider Implementation:
Demonstrates state management using Flutter's built-in Provider package with `ChangeNotifier`. Implements a hierarchical Parent-Category-Activity-Record model with reactive UI updates.  
`main.dart:8-13`

### GetX Implementation:
Shows the same functionality using GetX for state management, leveraging its reactive variables, dependency injection, and simplified navigation.  
`screens_getx.dart:14-28`

### MobX Implementation:
Implements the same model using MobX with observable properties, actions, and automatic code generation for boilerplate reduction.  
`mobix_buisiness_logic.dart:9-24`

## 7. Flutter/Dart Skills Demonstrated:

### State Management:
- **Provider**: Used for the core university system and one implementation of the Parent-Category-Activity model  
- **GetX**: Implemented for reactive state management with simplified syntax  
- **MobX**: Demonstrated with code generation for reduced boilerplate  


### Routing:
Uses Flutter's built-in `Navigator` for screen transitions with `MaterialPageRoute`. GetX implementation also demonstrates GetX's simplified navigation.  
`main.dart:81-84`  
`screens_getx.dart:22-24`

### Forms and validation:
Implements form fields with validation for login, registration, and exam inputs.  
`teacher_and_student.dart:142-157`

### Async programming:
Uses asynchronous programming for dialog interactions and navigation.  
`teacher_and_student.dart:173-188`

### Widgets:
- Custom screens for different user roles  
- Reusable patterns across different state management implementations  
- Complex UI with tabs, lists, and forms  
`teacher_and_student.dart:51-97`

## 8. Architecture & Design Decisions:

### Architecture pattern:
Uses a modified MVC pattern where:

- **Models**: Business logic classes (University, Student, Teacher, etc.)  
- **Views**: Screen widgets  
- **Controllers**: State management (Provider, GetX, MobX)  
`cep_business_logic.dart:88-107`

### Folder structure:
Organized by feature and state management approach:

- `lib/`: Core application files  
- `lib/screens/`: Main application screens  
- `lib/Provider_State_Management/`: Provider implementation  
- `lib/Getx_State_Management/`: GetX implementation  
- `lib/Mobix_State_Management/`: MobX implementation  
`main.dart:1-5`  
`screens_getx.dart:1-3`  
`mobix_buisiness_logic.dart:1-5`

### Testability and modularity:
- Clear separation of business logic from UI  
- Consistent model structure across implementations  
- Modular components that can be tested independently  
`cep_business_logic.dart:88-107`

## 9. Third-Party Tools & Packages:

- **Provider (^6.1.2)**: Used for implementing the core state management pattern with `ChangeNotifier`.  


- **GetX (^4.6.6)**: Used for implementing reactive state management with simplified syntax and built-in dependency injection.  


- **MobX (^2.0.7)** and **flutter_mobx (^2.0.6)**: Used for implementing reactive state management with observable properties and actions.  


- **build_runner (^2.1.11)** and **mobx_codegen (^2.0.7)**: Development dependencies for generating MobX boilerplate code.  


- **Flame (^1.15.0)**: Game development framework, though its usage is not evident in the provided code snippets.  


## 10. Advanced Concepts:

### Multiple state management implementations:
The project demonstrates three different state management approaches (Provider, GetX, MobX) implementing the same functionality, allowing for direct comparison of their strengths and weaknesses.  


### Code generation:
Uses `build_runner` and `mobx_codegen` for generating MobX boilerplate code, demonstrating advanced build processes.  
`mobix_buisiness_logic.g.dart:31-40`

### Hierarchical data modeling:
Implements complex nested data structures with reactive updates at multiple levels.  
`cep_business_logic.dart:36-85`

## 11. Biggest Technical Challenges & Solutions:

### Challenge 1: Managing hierarchical state
**Solution**: Implemented nested state management with proper propagation of changes up and down the hierarchy using different state management approaches.  
`screens.dart:23-41`

### Challenge 2: Consistent implementation across state management patterns
**Solution**: Maintained similar model structures and UI patterns while adapting to the specific requirements of each state management approach.  
`mobix_buisiness_logic.dart:9-24`  
`main.dart:8-13`

### Challenge 3: MobX code generation setup
**Solution**: Configured `build_runner` and `mobx_codegen` to generate the necessary boilerplate code for MobX observables and actions.  

`mobix_buisiness_logic.g.dart:31-40`

## 12. My Role:
Based on the git blame information, Abdul Haseeb appears to be the sole developer of this project, implementing all aspects including:

- Core university management system  
- Provider implementation  
- GetX implementation  
- MobX implementation  
- UI components and screens  
`main.dart:1-5`  
`screens_getx.dart:1-5`  
`mobix_buisiness_logic.dart:1-5`

## Notes:
This repository is primarily an educational project demonstrating different state management approaches in Flutter. The code shows implementations of Provider, GetX, and MobX for the same functionality, allowing for comparison. The project appears to be developed over a short period in June 2024 based on commit dates. While there's mention of Flame game development framework in the dependencies, its usage isn't evident in the provided code snippets.





<center>

# Repo 10: WorksOut

</center>

## GitHub Link (optional):

[HaseebKahn365/works_out](https://github.com/HaseebKahn365/works_out) (private)

## Duration/Timeline:

July 2023 - August 2023 (based on commit timestamps from July 25, 2023 to August 14, 2023)

## Project Description (2‚Äì5 lines):

WorksOut is a Flutter-based workout tracking application that allows users to record and visualize their workout data. It enables tracking of push-ups, pull-ups, and custom workouts, providing statistical visualization of progress over time. The app is designed for fitness enthusiasts who want to monitor their exercise routines.

## Key Features Implemented:

- User authentication system with Firebase Auth and Google Sign-in
- Workout tracking for push-ups and pull-ups with cloud synchronization
- Custom workout creation and tracking with local storage
- Statistical visualization with charts (line charts, pie charts, radial progress)
- Daily, weekly, monthly, and yearly workout records and statistics
- Responsive UI that adapts to different screen sizes
- Light/dark theme support with customizable color schemes

## Flutter/Dart Skills Demonstrated:

- State management using StatefulWidget
- FlutterFire integration (Firebase Auth, Firestore, Storage)
- Custom widgets development (charts, progress indicators)
- Local data persistence
- Responsive design implementation
- Cross-platform development
- Asynchronous programming with Futures

## Tools & Packages Used:

Key packages include:

- firebase_core
- firebase_auth
- cloud_firestore
- firebase_storage
- google_sign_in
- fl_chart (for data visualization)
- image_picker, image_cropper
- path_provider (for local storage)
- shared_preferences (for theme persistence)
- intl (for date formatting)

## Design Pattern or Architecture Used:

The application follows a modular architecture pattern with distinct systems responsible for different aspects of functionality:

The architecture is organized into four primary subsystems:

- Authentication System
- Workout Tracking System
- Statistics Visualization System
- Custom Workouts System

Each subsystem has clear responsibilities and interfaces with other parts of the application.

## Challenges Solved / Highlights:

- Implemented a dual storage system that uses Firebase for push-ups/pull-ups and local storage for custom workouts
- Created a sophisticated data visualization system with multiple chart types
- Developed a responsive UI that adapts between bottom navigation and side navigation based on screen width
- Built a comprehensive workout tracking system that maintains daily, weekly, monthly, and yearly statistics
- Implemented a theme management system with persistent user preferences
- Designed a data structure in Firestore that efficiently stores and retrieves workout history

## Notes

The repository appears to be a personal workout tracking application developed in Flutter with Firebase integration. The architecture is well-documented in the wiki, showing a modular approach with clear separation of concerns. The timeline was determined from git commit dates, showing development primarily in July-August 2023. The app demonstrates several Flutter skills including Firebase integration, custom widgets, and responsive design.





<center>

# Repo 11: Workouts_V3
</center>
Workouts_V3

### 2. GitHub Link:
[https://github.com/HaseebKahn365/workouts_v3](https://github.com/HaseebKahn365/workouts_v3)

### 3. Timeline & Commitment:
**November 2023 - June 2024** (based on commit dates from the codebase)  
`main.dart:3-5`

### 4. Project Overview:
Workouts_V3 is a Flutter application designed to track various types of activities and workouts. The app allows users to create, monitor, and analyze both count-based and time-based activities. It provides visualization tools to track progress over time through charts and statistics.

The target audience is individuals who want to track their daily activities, workouts, or habits with detailed record-keeping and progress visualization.

The core goals of the app are to help users track activity completion, visualize progress over time, predict the likelihood of completing activities based on historical patterns, and export activity data for further analysis.  
`today_screen.dart:1-8`

### 5. Core Functionality:

#### Screens/Pages and Flow:
The app has three main screens accessible via a bottom navigation bar (on mobile) or navigation rail (on wider screens):
- **Home Screen**: For creating and managing activities
- **Today Screen**: Shows today's progress and completion probabilities
- **Overall Screen**: Displays weekly progress charts and allows data export  
`main.dart:90-102`

#### Business Logic Layers:
The app uses a `Parent` class as the main data container, which holds a list of `Activity` objects. Each `Activity` contains dated records, image maps, and tag maps. The business logic includes probability calculations for activity completion and data processing for visualization.  
`overall_screen.dart:254-266`

#### Communication Between Modules:
The app uses Riverpod for state management, allowing different screens to access and modify the shared `Parent` object. Changes to activities trigger UI updates across the app.  
`main.dart:15`

#### Real-time or Offline Behavior:
The app supports both online and offline functionality. It uses Firebase for cloud storage and synchronization but also maintains local data persistence through SQLite and SharedPreferences.  
`sql_services.dart:164-177`

#### User Data Handling:
- **CRUD Operations**: Users can create, read, update, and delete activities
- **Sync**: Data is synchronized with Firebase Firestore
- **Local Storage**: Uses SQLite for structured data and SharedPreferences for app settings
- **Media Storage**: Images are stored in Firebase Storage with local caching  
`sql_services.dart:179-189`

#### Error, State, Navigation, and Animation Management:
- **State Management**: Uses Riverpod for reactive state management
- **Navigation**: Implements custom navigation with bottom navigation bar and navigation rail
- **Animations**: Uses `flutter_animate` package for UI animations
- **Error Handling**: Implements try-catch blocks for database and network operations  
`today_screen.dart:3`

### 6. Key Features:

#### Activity Tracking:
Users can create and track two types of activities: count-based (measured in repetitions) and time-based (measured in minutes). The app maintains a history of all activity records with timestamps.  
`home_screen.dart:51-60`

#### Progress Visualization:
The app provides multiple visualization methods:
- Progress bars comparing today's activity to personal bests
- Pie charts for time-based and count-based activities
- Line charts showing weekly progress  
`today_screen.dart:250-270`

#### Probability Calculation:
A distinctive feature that predicts the likelihood of completing activities based on historical patterns, using probability formulas and past data from the same hour of day.  
`today_screen.dart:5-6`

#### Data Export:
Allows exporting activity records to CSV format for external analysis, particularly useful in the web version of the application.  
`overall_screen.dart:454-474`

#### Media Attachment:
Users can attach images to activity records, which are stored in Firebase Storage and displayed in the activity details screen.  
`activity_screen.dart:11`

#### Tagging System:
Activities can be tagged for better organization and filtering.  
`activity_screen.dart:96-98`

### 7. Flutter/Dart Skills Demonstrated:

#### State Management:
Uses Riverpod for state management, creating a centralized `Parent` provider that holds all activities and their states. This allows for reactive UI updates when data changes.  
`main.dart:15`

#### Routing:
Implements custom navigation using a combination of bottom navigation bar for mobile and navigation rail for larger screens, with conditional rendering based on screen width.  
`main.dart:853-887`

#### Forms and Validation:
Implements form validation for activity creation and record entry, including input formatters for numeric fields.  
`activity_screen.dart:175-179`

#### Async Programming & Future/Stream Use:
Extensively uses async/await for database operations, Firebase interactions, and file operations. Implements Future-based data loading and processing.  
`sql_services.dart:148-162`

#### Custom Widgets:
Creates reusable widgets for charts, progress indicators, and activity cards. Implements complex UI components like expandable tiles and data tables.  
`overall_screen.dart:435-453`

### 8. Architecture & Design Decisions:

#### Architecture Pattern:
The app follows a modified MVVM (Model-View-ViewModel) pattern:
- **Model**: `Activity` and related data classes
- **View**: Screen widgets (`HomeScreen`, `Today`, `Overall`)
- **ViewModel**: `Parent` class with Riverpod for state management  
`overall_screen.dart:254-266`

#### Folder Structure and Separation of Concerns:
- `lib/`: Main application code
- `lib/buisiness_logic/`: Business logic classes and utilities
- `lib/screens/`: UI screens and components
- `assets/`: Static assets like images  
`db_table_view.dart:1-16`

#### Testability and Modularity:
The app demonstrates modularity through separation of concerns, with distinct classes for different responsibilities. The use of dependency injection via Riverpod enhances testability.  
`main.dart:21-24`

### 9. Third-Party Tools & Packages:

#### Firebase Suite:
- `firebase_core`, `cloud_firestore`, `firebase_storage`: Used for cloud data storage, synchronization, and image storage  


#### State Management:
- `flutter_riverpod`: Provides reactive state management throughout the app  


#### UI Enhancement:
- `flutter_animate`: Implements smooth animations for UI elements
- `fluentui_system_icons`: Provides consistent icon set
- `fl_chart`: Creates interactive charts for data visualization  




#### Media Handling:
- `image_picker`, `image_cropper`: For selecting and editing images
- `cached_network_image`: Efficiently loads and caches images from Firebase  


#### Data Export:
- `csv`, `syncfusion_flutter_xlsio`: For exporting activity data to CSV and Excel formats
- `flutter_share`: Enables sharing exported files  



#### Local Storage:
- `shared_preferences`: Stores app settings and user preferences
- `path_provider`, `path`: Manages file system access for data export  



### 10. Advanced Concepts:

#### Cross-Platform Support:
The app is designed to work on both mobile and web platforms, with responsive layouts that adapt to different screen sizes.  
`main.dart:68-70`

#### Offline Support:
Implements local database storage using SQLite to enable offline functionality, with synchronization to Firebase when online.  
`sql_services.dart:121-139`

#### Probability-Based Predictions:
Uses statistical models to predict activity completion likelihood based on historical patterns.  
`today_screen.dart:5-6`

#### Web-Specific Features:
Implements web-specific functionality like CSV export using `dart:html` for browser download capabilities.  
`overall_screen.dart:3-4`

### 11. Biggest Technical Challenges & Solutions:

#### Data Synchronization:
- **Challenge**: Maintaining data consistency between local storage and Firebase.
- **Solution**: Implemented a robust synchronization system with SQLite as local storage and Firebase as the cloud backend, with conflict resolution strategies.  
`sql_services.dart:164-205`

#### Cross-Platform UI:
- **Challenge**: Creating a responsive UI that works well on both mobile and web platforms.
- **Solution**: Used conditional rendering based on screen width to provide different navigation experiences (bottom bar vs. rail) and layout adjustments.  
`main.dart:853-887`

#### Performance Optimization:
- **Challenge**: Handling large datasets efficiently, especially for chart rendering.
- **Solution**: Implemented data processing methods to aggregate and prepare data for visualization, reducing the computational load during rendering.  
`overall_screen.dart:46-60`

### 12. My Role:
Based on the git blame information, it appears that Abdul Haseeb was the primary (or sole) developer of this project, implementing all aspects from UI design to business logic and database integration.  
`main.dart:1-5`

---

### Notes:
- This comprehensive overview is based on the available code snippets and wiki pages from the Workouts_V3 repository.
- The timeline is inferred from commit dates spanning from November 2023 to June 2024.
- The app demonstrates a well-structured Flutter application with cloud synchronization, local persistence, and advanced visualization features.







<center>

# Repo 12: Cellz Final (Currently Live)

</center>

**Cellz Final**
[https://play.google.com/store/apps/details?id=com.cellz.final](https://play.google.com/store/apps/details?id=com.cellz.final)


**Gameplay Trailer:** [https://www.youtube.com/shorts/RX07n2JUg6U](https://www.youtube.com/shorts/RX07n2JUg6U)

## GitHub Link:
(this is a private repo because this is currently in production)

## Timeline & Commitment:
**Start Date:** July 2024  
**End Date:** May 2025  

---

## Project Overview:
Cellz Final is a feature-rich puzzle game designed to provide an engaging and challenging experience for players of all ages. The game revolves around completing levels by achieving specific goals, such as collecting stars or solving puzzles within a time limit. It includes a variety of levels, animations, and sound effects to enhance the user experience.

The target audience includes casual gamers and puzzle enthusiasts. The app aims to provide entertainment while improving problem-solving skills and strategic thinking. Core goals include seamless gameplay, intuitive UI, and a rewarding progression system.

---

## Core Functionality:
### Internal Workflow:
- **Screens/Pages:**  
  The app includes multiple screens such as the Home Screen, Levels Journey, Game Play Screen, Profile Settings, and Friends Interaction.
  
- **Business Logic Layers:**  
  The app uses `Provider` for state management, ensuring a clean separation between UI and business logic. Game states, user data, and level progression are managed efficiently.

- **Communication Between Modules:**  
  Modules communicate via `Provider` and `ChangeNotifier`, ensuring reactive updates across the app.

- **Real-Time or Offline Behavior:**  
  The app supports offline gameplay with local data storage using `sqflite`. Online features like leaderboards and friend interactions are synced with Firebase.

- **User Data Handling:**  
  CRUD operations are implemented for user profiles, game progress, and settings. Data is synced with Firebase for online users and stored locally for offline users.

- **Error, State, Navigation, and Animations:**  
  Errors are handled gracefully with fallback UI. Navigation is managed using `GoRouter`, and animations are implemented using `flutter_animate` for smooth transitions.

---

## Key Features:
1. **Levels Journey:**  
   A timeline-based level progression system with visual indicators for completed, current, and locked levels.

2. **Custom Levels:**  
   Players can create and play custom levels, stored locally or shared with friends.

3. **Audio Integration:**  
   Background music and sound effects enhance the gaming experience. Audio settings are customizable.

4. **Friends Interaction:**  
   Add friends, share progress, and compete on leaderboards.

5. **Offline Support:**  
   Play seamlessly without an internet connection. Data syncs when online.

6. **Haptics and Animations:**  
   Integrated haptic feedback and smooth animations for an immersive experience.

---

## Flutter/Dart Skills Demonstrated:
- **State Management:**  
  Used `Provider` for managing game states, user data, and UI updates.

- **Routing:**  
  Implemented `GoRouter` for dynamic and declarative navigation.

- **Async Programming:**  
  Used `Future` and `Stream` for handling Firebase data sync and real-time updates.

- **Custom Widgets:**  
  Designed reusable widgets like `Grid`, `CircleWidget`, and custom dialogs for modularity.

- **Animations:**  
  Leveraged `flutter_animate` for shimmer effects, transitions, and smooth UI interactions.

---

## Architecture & Design Decisions:
- **Architecture Pattern:**  
  Followed MVVM (Model-View-ViewModel) for clean separation of concerns.

- **Folder Structure:**  
  Organized into `business_logic`, `providers`, `screens`, `widgets`, and `data` folders for modularity and scalability.

- **Testability:**  
  The app is modular and testable, with clear separation between UI and logic.

---

## Third-Party Tools & Packages:
1. **Firebase:**  
   Used for authentication, Firestore database, and cloud storage.

2. **sqflite:**  
   Local database for offline support.

3. **flutter_animate:**  
   For animations like shimmer effects and transitions.

4. **audioplayers:**  
   For background music and sound effects.

5. **timeline_tile:**  
   For the Levels Journey screen.

6. **carousel_slider:**  
   For showcasing levels and features.

---

## Advanced Concepts:
- **Firebase Integration:**  
  Implemented Firebase Authentication, Firestore, and Cloud Storage for real-time data sync.

- **Offline Support:**  
  Ensured seamless gameplay with local storage and sync mechanisms.

- **Haptics and Animations:**  
  Added haptic feedback and smooth animations for an immersive experience.

---

## Biggest Technical Challenges & My Solutions:
1. **Performance Issues with Audio:**  
   Resolved by optimizing audio playback and disabling unnecessary audio streams.

2. **Navigation Bugs:**  
   Fixed by migrating to `GoRouter` for a declarative and robust navigation system.

3. **Data Sync Conflicts:**  
   Implemented conflict resolution strategies for Firebase and local data sync.

---

## My Role:
I was the sole developer and designer of this project. I implemented all features, designed the UI/UX, and managed the integration of third-party tools. I also handled debugging, testing, and deployment to ensure a smooth user experience.




